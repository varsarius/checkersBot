//Generated by chatGPT, but should work.


// ScrollBox.js
// A reusable scrollable list container for HTML5 Canvas.
// Items should be objects with a draw(ctx, x, y, width, height, index) method.

export default class ScrollBox {
    /**
     * @param {HTMLCanvasElement} canvas - The canvas element to draw into and bind events on.
     * @param {Object[]} items - Array of item objects, each with a draw(ctx, x, y, width, height, index) method.
     * @param {Object} options
     * @param {number} options.x - X coordinate of the scroll box.
     * @param {number} options.y - Y coordinate of the scroll box.
     * @param {number} options.width - Width of the scroll box.
     * @param {number} options.height - Height of the scroll box.
     * @param {number} options.itemHeight - Fixed height of each item.
     * @param {number} [options.scrollbarWidth=10] - Width of the scrollbar.
     * @param {number} [options.minThumbHeight=20] - Minimum height of the scrollbar thumb.
     */
    constructor(canvas, items, options) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.items = items;
        const {
            x, y, width, height, itemHeight,
            scrollbarWidth = 10,
            minThumbHeight = 20
        } = options;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.itemHeight = itemHeight;
        this.scrollbarWidth = scrollbarWidth;
        this.minThumbHeight = minThumbHeight;

        // Scroll state
        this.scrollY = 0;
        this.maxScroll = Math.max(0, items.length * itemHeight - height);

        // Thumb geometry
        this._updateThumbMetrics();

        // Drag state
        this.dragging = false;

        // Bind event handlers
        this._bindEvents();
    }

    /** Update thumb size and position based on content/viewport */
    _updateThumbMetrics() {
        const {height, itemHeight, items, minThumbHeight, scrollbarWidth} = this;
        const contentHeight = items.length * itemHeight;
        // Thumb height proportional to viewport/content
        this.thumbHeight = Math.max(
            minThumbHeight,
            height * (height / contentHeight)
        );
        // Thumb Y position within track
        const scrollRatio = this.maxScroll > 0 ? this.scrollY / this.maxScroll : 0;
        this.thumbY = this.y + scrollRatio * (height - this.thumbHeight);
        this.trackX = this.x + this.width - scrollbarWidth;
        this.trackY = this.y;
    }

    /** Bind mouse and wheel events to the canvas */
    _bindEvents() {
        const c = this.canvas;
        c.addEventListener('wheel', this._onWheel = e => {
            const rect = c.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            if (mx >= this.x && mx <= this.x + this.width &&
                my >= this.y && my <= this.y + this.height) {
                e.preventDefault();
                this.scrollY = Math.min(
                    this.maxScroll,
                    Math.max(0, this.scrollY + e.deltaY)
                );
                this._updateThumbMetrics();
                this.requestDraw && this.requestDraw();
            }
        }, {passive: false});

        c.addEventListener('mousedown', this._onMouseDown = e => {
            const rect = c.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            // Check if clicking on the thumb
            if (
                mx >= this.trackX && mx <= this.trackX + this.scrollbarWidth &&
                my >= this.thumbY && my <= this.thumbY + this.thumbHeight
            ) {
                this.dragging = true;
                this.dragOffset = my - this.thumbY;
            }
        });

        c.addEventListener('mousemove', this._onMouseMove = e => {
            if (!this.dragging) return;
            const rect = c.getBoundingClientRect();
            const my = e.clientY - rect.top - this.dragOffset;
            // Clamp thumbY
            const minY = this.y;
            const maxY = this.y + this.height - this.thumbHeight;
            this.thumbY = Math.min(maxY, Math.max(minY, my));
            // Map back to scrollY
            const ratio = (this.thumbY - this.y) / (this.height - this.thumbHeight);
            this.scrollY = ratio * this.maxScroll;
            this.requestDraw && this.requestDraw();
        });

        ['mouseup', 'mouseleave'].forEach(evt =>
            c.addEventListener(evt, this._onMouseUp = () => {
                this.dragging = false;
            })
        );
    }

    /**
     * Set new items and recalculate metrics
     * @param {Object[]} newItems
     */
    setItems(newItems) {
        this.items = newItems;
        this.maxScroll = Math.max(0, newItems.length * this.itemHeight - this.height);
        this.scrollY = Math.min(this.scrollY, this.maxScroll);
        this._updateThumbMetrics();
    }

    /**
     * Draw the scroll box and its items. Call this inside your main render loop.
     */
    draw() {
        const ctx = this.ctx;
        // Clip and draw items
        ctx.save();
        // Draw border
        ctx.strokeStyle = '#000';
        ctx.strokeRect(this.x, this.y, this.width, this.height);
        // Clip
        ctx.beginPath();
        ctx.rect(this.x, this.y, this.width, this.height);
        ctx.clip();
        // Translate for scroll
        ctx.translate(0, -this.scrollY);
        // Draw each item via its draw() method
        this.items.forEach((item, index) => {
            const iy = this.y + index * this.itemHeight;
            item.draw(ctx, this.x, iy, this.width - this.scrollbarWidth, this.itemHeight, index);
        });
        ctx.restore();

        // Draw scrollbar track
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(this.trackX, this.trackY, this.scrollbarWidth, this.height);
        // Draw thumb
        ctx.fillStyle = '#888';
        ctx.fillRect(this.trackX, this.thumbY, this.scrollbarWidth, this.thumbHeight);
    }

    /**
     * Optional: Unbind events if you need to destroy the scroll box
     */
    destroy() {
        const c = this.canvas;
        c.removeEventListener('wheel', this._onWheel);
        c.removeEventListener('mousedown', this._onMouseDown);
        c.removeEventListener('mousemove', this._onMouseMove);
        c.removeEventListener('mouseup', this._onMouseUp);
        c.removeEventListener('mouseleave', this._onMouseUp);
    }
}

// Usage example:
// import ScrollBox from './ScrollBox.js';
//
// class MyItem {
//   constructor(text) { this.text = text; }
//   draw(ctx, x, y, w, h, idx) {
//     ctx.fillStyle = idx % 2 ? '#eee' : '#ddd';
//     ctx.fillRect(x, y, w, h - 2);
//     ctx.fillStyle = '#000';
//     ctx.fillText(this.text, x + 5, y + h / 2 + 4);
//   }
// }
//
// const canvas = document.getElementById('c');
// const items = Array.from({ length: 100 }, (_, i) => new MyItem(`Item #${i+1}`));
// const scrollBox = new ScrollBox(canvas, items, {
//   x: 20, y: 20, width: 200, height: 250, itemHeight: 30
// });
//
// function render() {
//   const ctx = canvas.getContext('2d');
//   ctx.clearRect(0, 0, canvas.width, canvas.height);
//   scrollBox.draw();
//   requestAnimationFrame(render);
// }
// render();
